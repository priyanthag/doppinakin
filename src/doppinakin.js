/**
 * Created by priyantha on 2/22/17.
 */
import timestamp from 'timestamp';
import Joi from 'joi';

import {get, forEach, set, pick, omit, isEmpty} from 'lodash';

import DBConnector from './lib/database/db-connector';

// base model is coupled with config for now. if this goes
// Open source as a separate module this needs to be removed

let dbConfig = null;
let modelConfig = null;

// Get the connection for the given model
let getConnection = async (model) => {
  let conName = 'default';
  if (!isEmpty(modelConfig)) {
    conName = get(modelConfig, model.collection).connection;
  }
  // get the config according to the model connection defined in the config

  const dbConnector = new DBConnector(
    conName == 'default' ? dbConfig : get(dbConfig, conName),
    conName
  );
  return await dbConnector.getConnection(conName);
};

class Doppinakin {
  constructor() {
    this.created_at = timestamp();
    this.updated_at = timestamp();
  }

  /**
   * _id is auto generated by the mongo itself when creating an docuemnt
   */
  get id() {
    return this._id;
  }

  /**
   * create at and updated at Setter and Getter
   * @param {Number} val
   */
  set createdAt(val) {
    this.created_at = val;
  }
  get createdAt() {
    return this.created_at;
  }

  set updatedAt(val) {
    this.updated_at = val;
  }
  get updatedAt() {
    return this.updated_at;
  }

  static validate = Joi;

  /**
   * Database config Setter and Getter
   * @param {Object} config
   */
  static setDatabaseConfig(config) {
    dbConfig = config;
  }
  static getDatabaseConfig() {
    return dbConfig;
  }

  /**
   * Model config Setter and Getter
   * @param {Object} config
   */
  static setModelConfig(config) {
    modelConfig = config;
  }
  static getModelConfig() {
    return dbConfig;
  }

  static populateObject(data, objInstance) {
    forEach(data, (val, key) => {
      set(objInstance, key, val);
    });
    return objInstance;
  }

  static hydrate() {
    throw new Error('hydrate function must implement in the child class');
  }

  static async validateSchema(obj) {
    let schema = Joi.object().keys({
      ...this.schema,
      created_at: Joi.date().timestamp().raw(),
      updated_at: Joi.date().timestamp().raw(),
      _id: Joi.optional(),
    });

    let result = Joi.validate(JSON.stringify(obj), schema);
    if (result.error !== null) {
      throw new Error(result.error);
    }
  }

  static async create(obj) {
    try {
      await this.validateSchema(obj);
      let con = await getConnection(this);
      let col = con.collection(this.collection);
      let modelObj = await col.insertOne(obj);

      if (get(modelObj.result, 'ok') === 1) {
        return modelObj.ops[0];
      }
      throw new Error(`Error in creating record ${JSON.stringify(obj)}`);
    } catch (e) {
      throw new Error(e);
    }
  }

  static async findById(id) {
    let con = await getConnection(this);
    let col = con.collection(this.collection);
    let modelObj = await col.findOne({_id: id});
    return this.hydrate(modelObj);
  }

  static async update(obj) {
    try {
      obj.updated_at = timestamp();
      await this.validateSchema(obj);
      let con = await getConnection(this);
      let col = con.collection(this.collection);
      let modelObj = await col.updateOne(pick(obj, '_id'), {$set: omit(obj, '_id')});
      if (get(modelObj.result, 'ok') === 1) {
        return obj;
      }
      throw new Error(`Error in updating record ${JSON.stringify(obj)}`);
    } catch (e) {
      throw new Error(e);
    }
  }

  static async delete(obj) {
    try {
      let con = await getConnection(this);
      let col = con.collection(this.collection);
      let modelObj = await col.deleteOne(pick(obj, '_id'));

      if (get(modelObj.result, 'ok') === 1) {
        return true;
      }
      throw new Error(`Error in updating record ${JSON.stringify(obj)}`);
    } catch (e) {
      throw new Error(e);
    }
  }
}

export default Doppinakin;
